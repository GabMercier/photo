---
/**
 * Gallery Page — All images from all posts
 *
 * Displays every individual image (hero + series) as a separate thumbnail.
 * - Search input filters by post title and tags
 * - Tag pills filter by post tags
 * - Clicking any image opens a slideshow of currently visible images
 * - Each image in slideshow has a "View Post" button
 */
import Base from '@layouts/Base.astro';
import GalleryImage, { type ImageOrientation } from '@components/GalleryImage.astro';
import FilterBar from '@components/FilterBar.astro';
import { getCollection } from 'astro:content';
import { getLocaleFromUrl, t, localized, localePath } from '@utils/i18n';
import { extractColorMetadata, getColorMetadataFromRgb, type ColorFamily, type ColorMood } from '@utils/extractColors';
import { getOptimizedImage } from '@utils/optimizedImage';

/**
 * Determine image orientation from gallerySize setting or aspect ratio
 * - If gallerySize is set (not 'auto'), use that directly
 * - Otherwise detect from aspect ratio
 */
function getImageOrientation(
  aspectRatio: number,
  gallerySize?: 'auto' | 'small' | 'portrait' | 'portrait-tall' | 'landscape' | 'featured'
): ImageOrientation {
  // Use explicit gallerySize if set
  if (gallerySize && gallerySize !== 'auto') {
    return gallerySize === 'small' ? 'square' : gallerySize;
  }
  // Auto-detect from aspect ratio
  if (aspectRatio < 0.85) return 'portrait';
  if (aspectRatio > 1.2) return 'landscape';
  return 'square';
}

const locale = getLocaleFromUrl(Astro.url);

const posts = (await getCollection('posts', ({ data }) => {
  return !data.draft && !data.private;
})).sort((a, b) => b.data.date.valueOf() - a.data.date.valueOf());

// Extract all unique tags across all posts
const allTags = [...new Set(posts.flatMap(p => p.data.tags))].sort();

// Build flat array of ALL images (hero + series)
// Each image carries its parent post's metadata for filtering
interface GalleryImageData {
  src: string;
  alt: string;
  postUrl: string;
  postTitle: string;
  tags: string[];
  focalPoint: 'left' | 'center' | 'right';
  colorFamily: ColorFamily;
  mood: ColorMood;
  orientation: ImageOrientation;
}

const allImages: GalleryImageData[] = [];

// Collect all unique color families for filter UI
const colorFamiliesSet = new Set<ColorFamily>();

// Extract colors from images at build time
for (const post of posts) {
  const slug = post.slug || post.id.replace(/\.md$/, '');
  const postUrl = localePath(`/posts/${slug}`, locale);
  const postTitle = localized(post.data.title, locale) || t('slideshow.viewPost', locale);
  const tags = post.data.tags;

  // Get color metadata: use existing glowColor if available, otherwise extract from image
  let colorMeta: { colorFamily: ColorFamily; mood: ColorMood; lightness: number };
  if (post.data.glowColor) {
    const glow = post.data.glowColor;
    colorMeta = getColorMetadataFromRgb(glow.r, glow.g, glow.b);
  } else {
    // Extract color from cover image at build time
    const extracted = await extractColorMetadata(post.data.coverImage.src);
    colorMeta = {
      colorFamily: extracted.colorFamily,
      mood: extracted.mood,
      lightness: extracted.lightness,
    };
  }
  colorFamiliesSet.add(colorMeta.colorFamily);

  // Get aspect ratio for hero image (for masonry layout)
  const heroImageData = await getOptimizedImage(post.data.coverImage.src);
  const heroOrientation = getImageOrientation(heroImageData.aspectRatio, post.data.gallerySize);

  // Add hero image (with focal point for cropping)
  allImages.push({
    src: post.data.coverImage.src,
    alt: localized(post.data.coverImage.alt, locale) || '',
    postUrl,
    postTitle,
    tags,
    focalPoint: (post.data.coverImage.focalPoint || 'center') as 'left' | 'center' | 'right',
    colorFamily: colorMeta.colorFamily,
    mood: colorMeta.mood,
    orientation: heroOrientation,
  });

  // Add series images if present (inherit color from parent post)
  if (post.data.images && post.data.images.length > 0) {
    for (const img of post.data.images) {
      const seriesImageData = await getOptimizedImage(img.src);
      const seriesOrientation = getImageOrientation(seriesImageData.aspectRatio);

      allImages.push({
        src: img.src,
        alt: localized(img.alt, locale) || '',
        postUrl,
        postTitle,
        tags,
        focalPoint: (img.focalPoint || 'center') as 'left' | 'center' | 'right',
        colorFamily: colorMeta.colorFamily,
        mood: colorMeta.mood,
        orientation: seriesOrientation,
      });
    }
  }
}

// Convert to sorted array for consistent filter ordering
const colorFamilies = Array.from(colorFamiliesSet).sort();
---

<Base title={t('nav.gallery', locale)}>
  <section class="gallery container">
    <header class="gallery__header">
      <h1 class="gallery__title">{t('nav.gallery', locale)}</h1>
    </header>

    <!-- Filter bar with search, tag pills, and color filters -->
    <FilterBar tags={allTags} colorFamilies={colorFamilies} />

    <!-- Gallery grid of individual images (masonry on desktop) -->
    <div class="gallery__grid" id="gallery-grid">
      {allImages.map((img, i) => (
        <GalleryImage
          src={img.src}
          alt={img.alt}
          postUrl={img.postUrl}
          postTitle={img.postTitle}
          tags={img.tags}
          index={i}
          focalPoint={img.focalPoint}
          colorFamily={img.colorFamily}
          mood={img.mood}
          orientation={img.orientation}
        />
      ))}
    </div>

    {allImages.length === 0 && (
      <p class="gallery__empty">{t('gallery.noResults', locale)}</p>
    )}
  </section>

  <script>
    /**
     * Gallery Slideshow Logic
     *
     * - Clicking an image opens the slideshow
     * - Only visible (non-filtered) images are included
     * - Each image has postUrl and postTitle for the "View Post" button
     */
    function initGallerySlideshow() {
      const galleryGrid = document.getElementById('gallery-grid');
      if (!galleryGrid) return;

      // Get all visible images and build slideshow array
      function getVisibleImages() {
        const visibleItems = galleryGrid.querySelectorAll('.gallery-image:not(.gallery-image--hidden)');
        return Array.from(visibleItems).map(item => ({
          src: item.dataset.src,
          alt: item.dataset.alt || '',
          postUrl: item.dataset.postUrl,
          postTitle: item.dataset.postTitle,
        }));
      }

      // Handle clicks on gallery images
      galleryGrid.addEventListener('click', (e) => {
        const button = (e.target as HTMLElement).closest('.gallery-image__button');
        if (!button) return;

        const galleryItem = button.closest('.gallery-image');
        if (!galleryItem || galleryItem.classList.contains('gallery-image--hidden')) return;

        // Get all visible images
        const visibleImages = getVisibleImages();

        // Find index of clicked image in visible images
        const clickedSrc = galleryItem.dataset.src;
        const startIndex = visibleImages.findIndex(img => img.src === clickedSrc);

        if (window.openSlideshow && visibleImages.length > 0) {
          window.openSlideshow(visibleImages, startIndex >= 0 ? startIndex : 0);
        }
      });
    }

    /**
     * Fill gaps in masonry grid by expanding trailing items
     * Only runs on desktop where masonry is active
     */
    function fillMasonryGaps() {
      if (window.innerWidth < 1024) return;

      const galleryGrid = document.getElementById('gallery-grid');
      if (!galleryGrid) return;

      const visibleItems = Array.from(
        galleryGrid.querySelectorAll('.gallery-image:not(.gallery-image--hidden)')
      ) as HTMLElement[];

      if (visibleItems.length === 0) return;

      // Get grid info
      const gridStyle = getComputedStyle(galleryGrid);
      const columns = gridStyle.gridTemplateColumns.split(' ').length;

      // Calculate total cells used by visible items
      let totalCells = 0;
      visibleItems.forEach(item => {
        const isLandscape = item.classList.contains('gallery-image--landscape');
        const isFeatured = item.classList.contains('gallery-image--featured');
        // Featured = 2×2 = 4 cells, Landscape = 2 cols, others = 1
        if (isFeatured) {
          totalCells += 2; // Only count column span for row calculation
        } else if (isLandscape) {
          totalCells += 2;
        } else {
          totalCells += 1;
        }
      });

      // Check if last row has gaps
      const remainder = totalCells % columns;
      if (remainder === 0) return; // Perfect fit

      const gapSize = columns - remainder;

      // Find the last few square items and expand them to fill gaps
      const squareItems = visibleItems
        .filter(item => item.classList.contains('gallery-image--square'))
        .slice(-gapSize);

      squareItems.forEach(item => {
        item.style.gridColumn = 'span 2';
      });
    }

    // Re-run gap filling when filters change
    function initMasonryGapFill() {
      fillMasonryGaps();

      // Listen for filter changes
      const filterBar = document.querySelector('.filter-bar');
      if (filterBar) {
        const observer = new MutationObserver(() => {
          // Reset any previous expansions
          const expanded = document.querySelectorAll('.gallery-image[style*="grid-column"]');
          expanded.forEach(item => (item as HTMLElement).style.gridColumn = '');
          // Re-calculate gaps
          setTimeout(fillMasonryGaps, 50);
        });

        const galleryGrid = document.getElementById('gallery-grid');
        if (galleryGrid) {
          observer.observe(galleryGrid, { attributes: true, subtree: true, attributeFilter: ['class'] });
        }
      }

      // Re-run on resize
      let resizeTimeout: ReturnType<typeof setTimeout>;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          const expanded = document.querySelectorAll('.gallery-image[style*="grid-column"]');
          expanded.forEach(item => (item as HTMLElement).style.gridColumn = '');
          fillMasonryGaps();
        }, 150);
      });
    }

    // Initialize on page load and after view transitions
    document.addEventListener('DOMContentLoaded', () => {
      initGallerySlideshow();
      initMasonryGapFill();
    });
    document.addEventListener('astro:page-load', () => {
      initGallerySlideshow();
      initMasonryGapFill();
    });
  </script>
</Base>

<style>
  .gallery {
    padding-top: var(--space-3xl);
  }

  .gallery__header {
    margin-bottom: var(--space-xl);
  }

  .gallery__title {
    font-family: var(--font-body);
    font-size: var(--text-sm);
    font-weight: 400;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--color-text-muted);
  }

  .gallery__grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: var(--space-sm);
  }

  @media (min-width: 640px) {
    .gallery__grid {
      grid-template-columns: repeat(3, 1fr);
    }
  }

  /* Desktop: Masonry layout with dense packing */
  @media (min-width: 1024px) {
    .gallery__grid {
      grid-template-columns: repeat(4, 1fr);
      grid-auto-rows: 220px;
      grid-auto-flow: dense;
      gap: var(--space-md);
    }
  }

  @media (min-width: 1440px) {
    .gallery__grid {
      grid-template-columns: repeat(5, 1fr);
      grid-auto-rows: 200px;
    }
  }

  .gallery__empty {
    text-align: center;
    color: var(--color-text-muted);
    padding: var(--space-4xl) 0;
  }
</style>
