---
/**
 * Feed Page â€” Chronological listing of all public posts
 */
import Base from '@layouts/Base.astro';
import PostCard from '@components/PostCard.astro';
import { getCollection } from 'astro:content';
import { getLocaleFromUrl, t, localePath } from '@utils/i18n';
import { extractColorMetadata } from '@utils/extractColors';

const locale = getLocaleFromUrl(Astro.url);

const allPosts = (await getCollection('posts', ({ data }) => {
  return !data.draft && !data.private;
})).sort((a, b) => b.data.date.valueOf() - a.data.date.valueOf());

// Extract glow colors for posts that don't have them in frontmatter
// Also check for grayscale images to use neutral color
const posts = await Promise.all(
  allPosts.map(async (post) => {
    const imagePath = post.data.coverImage.src;
    const colorMeta = await extractColorMetadata(imagePath);

    // For grayscale images, use neutral gray regardless of frontmatter
    if (colorMeta.colorFamily === 'neutral') {
      return {
        ...post,
        data: {
          ...post.data,
          glowColor: { r: 90, g: 90, b: 90, hex: '#5A5A5A' },
        },
      };
    }

    // Use existing glowColor from frontmatter if present
    if (post.data.glowColor) {
      return post;
    }

    // Otherwise use extracted color
    return {
      ...post,
      data: {
        ...post.data,
        glowColor: colorMeta,
      },
    };
  })
);
---

<Base title={t('nav.feed', locale)}>
  <section class="feed container">
    <div class="feed__content" id="feed-content">
      {posts.map((post) => (
        <PostCard post={post} layout="feed" />
      ))}
    </div>

    {posts.length === 0 && (
      <p class="feed__empty">{t('gallery.noResults', locale)}</p>
    )}
  </section>
</Base>

<script>
  // Fade-in animation with IntersectionObserver
  document.addEventListener('astro:page-load', () => {
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    if (prefersReducedMotion) {
      document.querySelectorAll('.post-card--feed').forEach(card => {
        card.classList.add('visible');
      });
      return;
    }

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          observer.unobserve(entry.target);
        }
      });
    }, {
      threshold: 0.3,
      rootMargin: '0px'
    });

    document.querySelectorAll('.post-card--feed').forEach(card => {
      observer.observe(card);
    });
  });
</script>

<style>
  .feed {
    /* Fixed positioning to take over viewport scroll */
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 0;
    max-width: none;
    overflow-y: auto;
    overflow-x: hidden;
    scroll-snap-type: y mandatory;
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
    /* Account for header in snap positioning */
    scroll-padding-top: var(--header-height);
  }

  /* Single-column content area */
  .feed__content {
    width: 100%;
    display: flex;
    flex-direction: column;
  }

  .feed__empty {
    text-align: center;
    color: var(--color-text-muted);
    padding: var(--space-4xl) 0;
  }
</style>
